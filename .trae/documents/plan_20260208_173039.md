# 实现线上版本消息传递功能

## 功能需求
1. 使用 Redis 存储消息，实现跨用户、跨会话的消息传递
2. 同类型的马之间可以传递消息
3. 下一个同类型马的用户可以收到上一个同类型马用户的消息

## 技术实现方案

### 1. 后端服务
- **技术栈**：Node.js + Express + Redis
- **依赖库**：
  - `express`：Web 框架
  - `ioredis`：Redis 客户端
  - `cors`：处理跨域请求
  - `helmet`：安全加固
  - `dotenv`：环境变量管理

### 2. Redis 数据结构
- **消息队列**：使用 Redis List 存储每种类型马的消息
- **键名设计**：`horse:messages:{horseId}`，例如 `horse:messages:1`
- **消息格式**：JSON 字符串，包含消息内容、用户名、时间戳等

### 3. API 设计
- **获取消息**：`GET /api/messages/:horseId`
  - 从对应类型马的消息队列中获取最新消息
- **提交消息**：`POST /api/messages/:horseId`
  - 将消息添加到对应类型马的消息队列中
- **获取统计**：`GET /api/stats`
  - 获取每种类型马的消息数量统计

### 4. 前端修改
- **API 调用**：使用 `fetch` 或 `axios` 调用后端 API
- **状态管理**：修改 `useEffect` 钩子，从后端获取消息
- **消息提交**：修改 `handleRelaySubmit` 函数，调用后端 API 提交消息
- **错误处理**：添加网络错误处理和加载状态

### 5. 消息传递流程
1. 用户选择马的类型后，进入 relay 步骤
2. 前端调用 `GET /api/messages/:horseId` 获取最新消息
3. 显示"来自上一匹马的祝福"
4. 用户输入消息并提交
5. 前端调用 `POST /api/messages/:horseId` 提交消息
6. 后端将消息添加到 Redis 队列
7. 下一个同类型马的用户进入时，重复步骤 2-6

### 6. 部署配置
- **服务器**：腾讯云服务器
- **Redis**：使用已安装的 Redis
- **端口**：设置合适的端口（如 3001）
- **防火墙**：确保端口开放
- **HTTPS**：配置 SSL 证书

## 代码实现

### 后端服务
```javascript
// server.js
const express = require('express');
const Redis = require('ioredis');
const cors = require('cors');
const helmet = require('helmet');
require('dotenv').config();

const app = express();
const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
});

app.use(helmet());
app.use(cors());
app.use(express.json());

// 获取消息
app.get('/api/messages/:horseId', async (req, res) => {
  try {
    const { horseId } = req.params;
    const key = `horse:messages:${horseId}`;
    
    // 获取最新的 10 条消息
    const messages = await redis.lrange(key, 0, 9);
    
    if (messages.length > 0) {
      // 随机选择一条消息
      const randomIndex = Math.floor(Math.random() * messages.length);
      const message = JSON.parse(messages[randomIndex]);
      res.json({ success: true, message: message.content });
    } else {
      res.json({ success: false, message: '这是你的首条马蹄印，没人接你哦' });
    }
  } catch (error) {
    console.error('Error getting message:', error);
    res.json({ success: false, message: '获取祝福失败，请重试' });
  }
});

// 提交消息
app.post('/api/messages/:horseId', async (req, res) => {
  try {
    const { horseId } = req.params;
    const { content, username } = req.body;
    
    if (!content || !content.trim()) {
      return res.status(400).json({ success: false, message: '消息内容不能为空' });
    }
    
    const key = `horse:messages:${horseId}`;
    const message = {
      content: content.trim(),
      username: username || '匿名牛马',
      timestamp: new Date().toISOString(),
    };
    
    // 添加消息到队列
    await redis.lpush(key, JSON.stringify(message));
    
    // 限制队列长度为 100 条
    await redis.ltrim(key, 0, 99);
    
    res.json({ success: true, message: '消息传递成功！' });
  } catch (error) {
    console.error('Error submitting message:', error);
    res.status(500).json({ success: false, message: '消息传递失败，请重试' });
  }
});

// 获取统计
app.get('/api/stats', async (req, res) => {
  try {
    const stats = {};
    // 假设马的类型 ID 为 1-10
    for (let i = 1; i <= 10; i++) {
      const key = `horse:messages:${i}`;
      const count = await redis.llen(key);
      stats[i] = count;
    }
    res.json({ success: true, stats });
  } catch (error) {
    console.error('Error getting stats:', error);
    res.status(500).json({ success: false, message: '获取统计失败' });
  }
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### 前端修改
```javascript
// 修改 App.tsx 中的相关代码

// 1. 修改 useEffect 获取消息
useEffect(() => {
  if (step === GameStep.RELAY && myHorse) {
    const fetchMessage = async () => {
      try {
        const response = await fetch(`/api/messages/${myHorse.id}`);
        const data = await response.json();
        if (data.success) {
          setIncomingMessage(data.message);
        } else {
          setIncomingMessage(data.message || "这是你的首条马蹄印，没人接你哦");
        }
      } catch (error) {
        console.error('获取消息失败:', error);
        setIncomingMessage("这是你的首条马蹄印，没人接你哦");
      }
    };
    fetchMessage();
  }
}, [step, myHorse]);

// 2. 修改 handleRelaySubmit 提交消息
const handleRelaySubmit = async () => {
  if (!userRelayInput.trim()) {
    setErrorMsg("怎么也得哼哼两句吧？");
    return;
  }
  
  // 敏感词检查
  if (!isFromRandomPool) {
    const hasBlessing = FORBIDDEN_BLESSINGS.some(word => userRelayInput.includes(word));
    if (hasBlessing) {
      setErrorMsg(getRandom(FORBIDDEN_WARNINGS));
      return;
    }
    const hasSensitive = SENSITIVE_WORDS.some(word => userRelayInput.toLowerCase().includes(word));
    if (hasSensitive) {
      setErrorMsg(SENSITIVE_WARNING);
      return;
    }
  }
  
  try {
    // 提交消息到后端
    const response = await fetch(`/api/messages/${myHorse?.id}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ content: userRelayInput, username }),
    });
    
    const data = await response.json();
    if (data.success) {
      setToastMessage("🎉 传递成功");
      setToastType("success");
      setShowToast(true);
      
      setTimeout(() => {
        bgmRef.current?.stop();
        setShowToast(false);
        if (Math.random() > 0.6) {
          generateLeaderboard();
          setShowLeaderboard(true);
        } else {
          setStep(GameStep.RESULT);
        }
      }, 1200);
    } else {
      setErrorMsg(data.message || "消息传递失败，请重试");
    }
  } catch (error) {
    console.error('提交消息失败:', error);
    setErrorMsg("网络错误，请重试");
  }
};
```

## 部署步骤
1. **安装依赖**：在服务器上安装 Node.js、npm 和 Redis
2. **创建后端项目**：初始化项目，安装所需依赖
3. **配置环境变量**：创建 .env 文件，配置 Redis 连接信息
4. **启动服务**：使用 PM2 或 Systemd 管理后端服务
5. **配置前端**：修改前端 API 调用地址，指向后端服务
6. **构建前端**：运行 `npm run build` 构建前端项目
7. **部署前端**：将构建后的前端文件部署到服务器
8. **测试功能**：测试消息传递功能是否正常工作

## 扩展功能
1. **消息审核**：添加消息审核机制，过滤不良内容
2. **用户标识**：添加用户标识，实现更复杂的消息传递逻辑
3. **实时通知**：使用 WebSocket 实现实时消息通知
4. **消息统计**：统计每种类型马的消息数量，用于排行榜
5. **消息历史**：提供消息历史查询功能

## 技术优势
- **高性能**：Redis 作为内存数据库，提供高性能的消息存储和检索
- **可扩展性**：Redis 支持集群部署，可根据需要扩展
- **可靠性**：Redis 支持持久化，确保消息不会丢失
- **易于维护**：代码结构清晰，易于维护和扩展
- **跨平台**：支持各种前端框架和后端语言